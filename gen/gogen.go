package gen

import (
	"fmt"
	"io"
	"reflect"

	"github.com/dave/jennifer/jen"
)

const handlerPackageName = "github.com/y-akahori-ramen/ueLogHandler"

func appendGoType(statement *jen.Statement, typename string) error {
	switch typename {
	case "float":
	case "double":
		statement.Float64()
		return nil
	case "int32":
		statement.Int32()
		return nil
	case "uint32":
		statement.Uint32()
		return nil
	case "int64":
		statement.Int64()
		return nil
	case "uint64":
		statement.Uint64()
		return nil
	case "bool":
		statement.Bool()
		return nil
	case "string":
		statement.String()
		return nil
	case "vector2":
		statement.Qual(handlerPackageName, "FVector2D")
		return nil
	case "vector3":
		statement.Qual(handlerPackageName, "FVector")
		return nil
	}

	return fmt.Errorf("GetGoType:Invalid typename:%s", typename)
}

func genStructureCode(structureName string, info StructureInfo) ([]jen.Code, error) {
	code := []jen.Code{}

	headerName := fmt.Sprintf("%sHeader", structureName)
	headerFields := []jen.Code{}
	for fieldName, value := range info.Header {
		field := jen.Id(fieldName)
		switch value.(type) {
		case string:
			field.String()
		case float64:
			field.Float64()
		case int:
			field.Int32()
		case bool:
			field.Bool()
		default:
			return nil, fmt.Errorf("genStructureCode: Invalid Header Value Type Field:%s Value:%v Type:%s", fieldName, value, reflect.TypeOf(value))
		}
		headerFields = append(headerFields, field)
	}
	header := jen.Type().Id(headerName).Struct(headerFields...)
	code = append(code, header)

	bodyName := fmt.Sprintf("%sBody", structureName)
	bodyFields := []jen.Code{}
	for fieldName, typeName := range info.Body {
		field := jen.Id(fieldName)
		err := appendGoType(field, typeName)
		if err != nil {
			return nil, err
		}
		bodyFields = append(bodyFields, field)
	}
	body := jen.Type().Id(bodyName).Struct(bodyFields...)
	code = append(code, body)

	dataName := fmt.Sprintf("%sData", structureName)
	dataType := jen.Type().Id(dataName)
	dataType.Qual(handlerPackageName, "TStructuredData")
	dataType.Types(jen.Id(headerName), jen.Id(bodyName))
	code = append(code, dataType)

	dataHandlerFuncName := fmt.Sprintf("%sHandlerFunc", structureName)
	dataHandlerFuncType := jen.Type().Id(dataHandlerFuncName)
	dataHandlerFuncType.Func().Params(jen.Id(dataName), jen.Qual(handlerPackageName, "Log"))
	dataHandlerFuncType.Params(jen.Error())
	code = append(code, dataHandlerFuncType)

	logHanderTypeName := fmt.Sprintf("%sLogHandler", structureName)
	logHanderType := jen.Type().Id(logHanderTypeName)
	logHanderType.Struct(jen.Id("f").Id(dataHandlerFuncName))
	code = append(code, logHanderType)

	logHanderTypeNameRef := fmt.Sprintf("*%s", logHanderTypeName)
	logHandlerFuncType := jen.Func().Params(
		jen.Id("h").Id(logHanderTypeNameRef),
	).Id("Type").Params().String().Block(
		jen.Return(jen.Lit(structureName)),
	)
	code = append(code, logHandlerFuncType)

	logHandlerFuncHandle := jen.Func().Params(
		jen.Id("h").Id(logHanderTypeNameRef),
	).Id("Handle").Params(
		jen.Id("json").String(),
		jen.Id("log").Qual(handlerPackageName, "Log"),
	).Error().Block(
		jen.List(jen.Id("data"), jen.Err()).Op(":=").Qual(handlerPackageName, "JSONToStructuredData").Types(jen.Id(headerName), jen.Id(bodyName)).Call(jen.Id("json")),
		jen.If(jen.Err().Op("!=").Nil()).Block(jen.Return(jen.Err())),
		jen.Return(jen.Id("h.f").Call(jen.Id(dataName).Call(jen.Id("data")), jen.Id("log"))),
	)
	code = append(code, logHandlerFuncHandle)

	newLogHandlerFunc := jen.Func().Id(fmt.Sprintf("New%s", logHanderTypeName)).Params(
		jen.Id("f").Id(dataHandlerFuncName),
	).Qual(handlerPackageName, "StructuredLogDataHandler").Block(
		jen.Return(jen.Op("&").Id(logHanderTypeName).Values(jen.Dict{jen.Id("f"): jen.Id("f")})),
	)
	code = append(code, newLogHandlerFunc)

	return code, nil
}

func GenGoFile(w io.Writer, packageName string, infoList StructureInfoList) error {
	f := jen.NewFile(packageName)
	f.ImportAlias(handlerPackageName, "ueloghandler")

	f.HeaderComment("Code generated by structuregen. DO NOT EDIT.")
	for structureName, info := range infoList {
		codes, err := genStructureCode(structureName, info)
		if err != nil {
			return err
		}

		for _, code := range codes {
			f.Add(code)
		}
	}

	return f.Render(w)
}
